---
title: "High resolution gridding"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, message = FALSE, warning = FALSE)
```

### Preamble

A short piece of code demonstrating fine-scale gridding.

### Generate some artifical data

Generate a small spatial dataframe of one million observations (imagine these are vms-pings of from vessels while trawling):
```{r}
library(tidyverse)
df <- data_frame(lon =    rnorm(n = 1e6, mean =  -28, sd =   6),
                 lat =    rnorm(n = 1e6, mean =   64, sd =   0.3),
                 effort = rnorm(n = 1e6, mean = 1000, sd = 200))  # unit in minutes
```

### Create a gridding functions

```{r}
# code from ziggy stardust
#   note that here there is not validation/testing done
#   read: use stuff at own risk

encode_zchords <- function(x, y, dx = 1, dy = 0.5 * dx, invalids = TRUE) {

  x.brks <- seq(floor(min(x)),ceiling(max(x)),dx)
  x.ints <- findInterval(x, x.brks, all.inside = TRUE)
  x <- (x.brks[x.ints] + x.brks[x.ints + 1]) / 2

  y.brks <- seq(floor(min(y)),ceiling(max(y)),dy)
  y.ints <- findInterval(y, y.brks, all.inside = TRUE)
  y <- (y.brks[y.ints] + y.brks[y.ints + 1]) / 2

  if(invalids) {
    x <- ifelse(x >= -180 & x <= 180, x, NA)
    y <- ifelse(y >= -90  & y <= 90 , y, NA)
  }

  return(paste(round(x,6), round(y,6), sep = ":"))

}
```


### Grid the data

Here we use a 0.05 decimal degree resolution or grid for the lon, 0.025 for the lat:
```{r}
d <- 
  df %>% 
  mutate(sq = encode_zchords(lon, lat, dx = 0.05, dy = 0.025), type = "zchords") %>% 
  group_by(sq) %>% 
  summarise(effort = sum(effort) / 60/1000) %>% # scale to lets say thousand hours
  separate(sq, c("lon", "lat"), sep = ":", convert = TRUE, remove = FALSE)
```

What do we have:
```{r}
glimpse(d)
```

The character variable **sq** is the coded "square". Here, differently from e.g. the ICES statistical rectangle or the csquare encoding system the mid points for lon and lat are embedded in the square encoding, separated by a colon. Hence getting the value of the lon and the lat is as simple as calling the now hopefully familiar `separate`-function.

### The plot

```{r}
d %>% 
  ggplot(aes(lon, lat, fill = effort)) +
  geom_raster() +
  coord_quickmap()
```

### What to do about all this white space in the html-documentation??

... code pending, we are still working on this `floor`-issue ... :-).

below is just a placeholder for code-segments that may be a seeder for a solution:

```{r, eval = FALSE}

ranges <- data_frame(x.range = c(-10, -22),
                     y.range = c(64, 66))

x.center <- sum(ranges$x.range) / 2
y.center <- sum(ranges$y.range) / 2

# compute distance corresponding to 1 degree in either direction
# from the center
x.dist <- ggplot2:::dist_central_angle(x.center + c(-0.5, 0.5), rep(y.center, 2))
y.dist <- ggplot2:::dist_central_angle(rep(x.center, 2), y.center + c(-0.5, 0.5))
# NB: this makes the projection correct in the center of the plot and
#     increasingly less correct towards the edges. For regions of reasonnable
#     size, this seems to give better results than computing this ratio from
#     the total lat and lon span.

# scale the plot with this aspect ratio
ratio <- y.dist / x.dist


ggplot2:::dist_central_angle <- function (lon, lat)
{
  lat <- lat * pi/180
  lon <- lon * pi/180
  hav <- function(x) sin(x/2)^2
  ahav <- function(x) 2 * asin(x)
  n <- length(lat)
  ahav(sqrt(hav(diff(lat)) + cos(lat[-n]) * cos(lat[-1]) *
              hav(diff(lon))))
}
```

